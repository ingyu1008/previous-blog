---
title: "2021년도 SCPC 1차 예선 풀이 및 후기"
date: 2021-07-17 18:00:00 +0900
tags:
    - PS
    - SCPC
categories:
    - PS
classes: wide
---

<script type="text/javascript" 
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>

이 글에 게시된 모든 문제는 codeground.org 에서 풀어보실 수 있습니다.

올해 SCPC 대회 결과는 다음과 같았다.

| 문제 번호 | 문제 이름   | 만점 | 제출 횟수 | 취득 점수 |
| --------- | ----------- | ---- | --------- | --------- |
| 1         | 친구들      | 80   | 1/10      | 80.0      |
| 2         | 이진수      | 150  | 1/10      | 150.0     |
| 3         | No Cycle    | 180  | 10/10     | 93.0      |
| 4         | 예약 시스템 | 190  | 2/20      | 37.0      |
| 5         | 차이        | 200  | 2/10      | 51.0      |

1, 2번 문제는 쉬워서 빠르게 풀었지만, 3,4,5번 문제는 만점을 받지 못했다. 2번과 3번 문제를 풀면서 너무 어렵게 생각했다고 느꼈고, 5번 문제를 보면서 구현능력이 부족하다는 느낌을 받았다.

올해 들어 비트마스킹 문제를 좀 풀었었는데 그 때문인지 그룹 1의 작은 제한에 비트마스킹을 하는 풀이로 일단 긁어야 하나 라는 생각이 자꾸 들어서 만점 풀이를 떠올리는데 시간이 들었다.

5번 문제에서는 Conflict가 나는 정점에서 인접한 정점으로 전파시켜 줘야된다고 생각했는데, 대회 종료 30분전에 그럴 필요 없다는 것을 깨달았다. 어차피 1차 예선을 붙을 거라고 생각하고 따로 구현하지는 않았다.

<details>
<summary>1. 친구들</summary>
<div markdown="1">

    - 그룹 1 (30 점) :  $$ N \le 1,000 $$
    - 그룹 2 (50 점) : 이 그룹의 테스트 케이스에서는 원래의 조건 외에는 다른 제약조건이 없다.

1. 30점 부분 점수의 경우 $$O(N^2)$$으로 번호 $$i + D_i$$인 사람의 모든 친구를 자신의 친구로 추가하는 과정을 $$N$$번을 반복하는 코드를 구현하기만 하면 된다.

2. 만점을 받기 위해서는 Disjoint Set 이라는 자료구조를 통해 $$i$$번과 $$i + D_i$$번을 union 하고, 서로 다른 집합의 개수를 세어 주면 된다.

</div>
</details>

<details>
<summary>2. 이진수</summary>
<div markdown="1">

    - 그룹 1 (31 점) : 이 그룹의 테스트 케이스에서는 $$n \le 15$$이다.
    - 그룹 2 (38 점) : 이 그룹의 테스트 케이스에서는 $$n \le 1,000$$이다.
    - 그룹 3 (81 점) : 이 그룹의 테스트 케이스에서는 $$n \le 50,000$$이다.

1. 31점만 받는 풀이는 모든 가능한 A에 대해 B를 계산 해보는 것이다. 가능한 A의 개수가 최대 $$2^n$$개 이므로 그룹 1의 경우 시간 내에 해결 가능하다.

2. 그룹 2는 $$O(N^2)$$ 풀이를 구현하는 경우 맞을 수 있게 된다. 하지만 어떻게 풀어야 $$O(N^2)$$인지 이해하지 못하겠다.

3. 만점을 받기 위해서는 $$O(N)$$풀이를 구현해야 한다. $$B$$의 좌우에 1을 2개씩 붙인 다음 $$A$$에 1을 넣을 수 있을 때마다 항상 넣어주는 것이 먼저다. 이후 그리디하게 앞에서부터 0으로 바꿀 수 있는 곳을 0으로 바꿔주면 가장 작은 $$A$$ 를 찾을 수 있다.

</div>
</details>

<details>
<summary>3. No Cycle</summary>
<div markdown="1">

    - 그룹 1 (41 점) : 이 그룹의 테스트 케이스에서는 $$3 \le N \le 10$$, $$0 \le M \le 20$$, $$1 \le K \le 10$$이다.
    - 그룹 2 (52 점) : 간선들에 방향을 부여할 수 있는 방법이 유일하다.
    - 그룹 3 (87 점) : 이 그룹의 테스트 케이스에서는 원래의 조건 외에는 다른 제약조건이 없다.

1. 그룹 1의 경우 가능한 경우 $$2^10$$개에 대해 모두 해보는 풀이를 구현하면 된다.

2. 그룹 2는 간선에 방향을 부여할 수 있는 방법이 유일하므로 하나씩 들어오는 간선에 대해 들어오는 대로 간선 추가가 가능하면 그렇게 하고, 불가능 하면 반대 방향으로 추가하는 방식을 이용하면 된다.

3. TODO

</div>
</details>

<details>
<summary>4. 예약 시스템</summary>

    - 그룹 1 ( 37점) : 이 그룹의 테스트 케이스에서는 모든 $$l_i$$ 가 짝수이다.
    - 그룹 2 ( 51점) : 이 그룹의 테스트 케이스에서는 모든 $$l_i$$ 가 홀수이다
    - 그룹 3 ( 102점) : 이 그룹의 테스트 케이스에서는 원래의 조건 외에는 다른 제약조건이 없다.

1. 이 문제는 그룹 1밖에 풀지 못했다. 모든 $$l_i$$가 짝수인 경우 나올 수 있는 블럭의 형태는 한가지로 정해져 있다. 어떤 블럭이 ㄱ자 또는 ㄴ 처럼 생긴 경우에는 ㅁ 자의 형태로 바꿔 주는 것이 항상 이득임을 쉽게 증명할 수 있다. 따라서 그냥 계산만 해주면 된다.

2. TODO

3. TODO

</details>

<details>
<summary>5. 차이</summary>
<div markdown="1">

    - 그룹 1 (31 점) : 이 그룹의 테스트 케이스에서는 $$1 \le N \le 1,000$$, $$1 \le K \le 2,000$$ 이다. 모든 1번 종류 쿼리에서 차이 값은 $$0$$이다.
    - 그룹 2 (28 점) : 이 그룹의 테스트 케이스에서는 $$1 \le N \le 1,000$$, $$1 \le K \le 2,000$$ 이다.
    - 그룹 3 (20 점) : 이 그룹의 테스트 케이스에서는 모든 1번 종류 쿼리에서 차이 값은 $$0$$이다.
    - 그룹 4 (121 점) : 이 그룹의 테스트 케이스에서는 원래의 조건 외에는 다른 제약조건이 없다.

1. 나이브하게 구현하고 입력받는 차이 값이 모두 0이므로 출력은 항상 0 또는 NC이다.

2. TODO

3. Union-Find 자료구조를 통해 구현하고 그룹 1과같이 출력은 항상 0 또는 NC이다.

4. TODO

</div>
</details>
